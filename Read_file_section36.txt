Chapter : PODS AND CONTAINERS

******Application Configuration*****
1) Most people already understand "configuration" as settings that influence the operation of an application.
2) Kubernetes allows user to pass dynamic configuration values to application at Runtime.
3) These dynamic Configuration helps user to control the Application Flow(Config Maps, secrets)

**ConfigMap: ***

1) Keep the Non-Sensitive Data in ConfigMap, which can be passed to Container Application.
2) Config Map Store Data in Key-Value format.
3) ConfigMaps allow you to separate your configurations from your Pods and components.
4) ConfigMap helps to makes configurations easier to change and manage, and prevents hardcoding configuration data to Pod specifications.
5) Config Map via Config File.
    kubectl create configmap [NAME] --from-file [/PATH/TO/ FILE.PROPERTIES] --from-file [/PATH/TO/FILE2.PROPERTIES]
    or
    kubectl create configmap [NAME] --from-file [/PATH/TO/ DIRECTORY]
6) Get ConfigMap via CLI.
    kubectl get configmap <Config_map_name> -o yaml/json

**Secrets***

1) Secrets are similar to ConfigMap but designed to keep the Sensitive Data.
2)  Create Secrets from file.
    kubectl create secret generic db-user-pass --from-file=./username.txt —from-file=./password.txt
3) Note : Special characters such as $, \, *, and ! require escaping.
4) Get Secrets.
    kubectl get secrets
5) Describe Secrets.
    kubectl describe secrets <Secret_name>


***types to pass data to CONTAINERS****

1) env variables  --refer section36_configmap-env-demo.yml 
2) volumes  --refer section36_configmap-vol-demo.yml
3) posix configmap --refer section36_configmap-posix-demo.yml

Three ways to create configuration file
1) yaml file  --refer section36-example-configMap.yml and section36-example-secret.yml and section36_configmap-env-demo.yml
2) posix file --refer section36-posix-example-configMap.yml and section36_configmap-posix-demo.yml
3) by file. --refer section36_nginx-pod.yml

CREATE CONFIG AND SECRET MAP FROM FILE.

Refer the section36_nginx-pod.yml ans section36_nginx.conf

# We try again the config map and secret.
# this time we will read the config map and secret from a file and we will set up a practical nginx pod
# we will create a secret from a file.
# Then we will create a config map from a file.
# In The Secret from a file, we will create a secret of password and in the create config from a file,
# we will create a custom and nginx file.
# Then we will set up an nginx pod and we will set up a pod that will authenticate from a HT access password.

# Prequiste before executing this manifest.
# Need to install the ht access(apache2-utils) on singlenode 
# a) cd to the directory where script are stored.
# b) sudo apt-get update
# c) sudo install apache2-utils
# d) To create HT access, will need to execute this command
#   htpasswd -c .htpasswd user
# user is username, create password and remember.
# e) execute ls command
# we see that .htpasswd is created.
# f) if we cat .htpasswd , we will see the encrpted password.
# g) Now we need to create the secret file using these htpasswd.
# h) kubectl create secret generic <name as you want> --from-file .htpasswd
#    kubectl create secret generic nginx-htpasswd --from-file .htpasswd
# i) check if secret file is created
#   kubectl get secrets
# j) kubectl describe secrets <secret file name>
# k) Once we created secret in cluster, we can remove the .htpasswd file
#   rm -f .htpasswd
# L) Now we need to create a configMap from the nginc conf file.
# Note: copy the content from nginx.conf 
# m) go to vi editor and name nginx.conf
# paste the copied content in vi editor, save and exit.
# n) Now create a configmap.
#  kubectl create configmap <give_new_file_name> --from-file <confg file name>
#  kubectl create configmap nginx-config-file --from-file nginx.conf
# o) describe the create configmap
#  kubectl describe configmap nginx-config-file
# p) Now we have created config and secret in cluster, next deploy pod using these config and secret maps and volume method.
# q) go to vi editor and name it has nginx-pod.yaml
# r) copy the content from above and save and exit
# s) create a pod, kubectl apply -f <nginx-pod.yaml>
# t) kubectl get pods
# u) curl <ip addres of pod>
# Note: we get error cos we need authentication.
# v) curl -u <username>:<password> <ip adress of pod> 
#    curl -u user:test123 172.17.0.5
# Now we are able to authenticate to nginx application.

Next topic

Resource request and resource limit.
refer section36_resource_limit.yml and section36_request_limit.yml

# Resource Request
# 1) Resource request allows user to define a resource limit, user expect a container to use.
# 2) Kube Scheduler will manage resource request and avoid scheduling on node, which don’t have enough resources.
# 3) Note : Containers are allowed to use more or less than the request resource. Resource Request is to manage the scheduling only.
# 4) Memory is measure in Bytes. User is allowed to define in MegaByte as well.
# 5) Requests for CPU resources are measured in cpu units. 1 vCPU means 1000 CPU Unit.

# Resource Limit
# 1) Resource Limits used to Limit the container’s resource uses.
# 2) Limits are imposed at RunTime Container.

# Execute on singlenode.

# steps
# 1) Go to directory where scripts are stored, cd <diretory_name>
# 2) Go to vi editor and name it using pod.yaml
# 3) copy the content from above and save the file.
# 4) create a pod, kubectl apply -f <file-name.yml>
# 5) check if pod is created, kubectl get pods
# 6) check describe of pod, kubectl desribe pod <pod-name>

Next topic : Container health check methods

1) Container Health
2) Liveness Probe
3) StartUp Probe
4) Readiness Probe

CONTAINERS Health:

1) Kubernetes is feature Rich, and provide number of features to monitor the containers.
2) Active Monitoring Helps K8s to decide the container state and Auto Restart in Case of Container Failure.

Liveness Probe : (Refer section36_liveness-hc.yml)
1) Liveness probe helps to determine the Container State.
2) By Default, K8s only consider container to be down, if container process stops.
3) Liveness probe helps user to improve & customized this Container Monitoring mechanism.
4) User can execute Two types of Liveness probes - Run Command in Container, Periodic HTTP Health Check.
5) Liveness via Container Command manifest.
6) initialDelaySeconds: How long to wait before sending a probe after a container starts.
7) periodSeconds: How often a probe will be sent.
8) Liveness via HTTP Request manifest.
9) timeoutSeconds: How long a request can take to respond before it’s considered a failure.

StartUp Probe : (Refer section36_startup-hc.yml)
1) Setting up Liveness probe is very Tricky with Application which have Long StartUp Time.
2) StartUp probe runs at container StartUp and stop running once container success.
3) Once the startup probe has succeeded once, the liveness probe takes over to provide a fast response to container deadlocks.
4) StartUp via HTTP Request manifest.
5) failureThreshold: When a probe fails, Kubernetes will try failure Threshold times before giving up.
6) Application will have a maximum of 5 minutes (30 * 10 = 300s) to finish its startup.

Readiness Probe : (Refer section36_readiness-hc.yml)
1) Readiness is used to detect if a container is ready to accept traffic.
2) Sometimes application might need to load large data or configuration files during startup, or depend on external services after startup.
3) NO Traffic will be sent to a pod until container pass the Readiness Probe.
4) Readiness Probe manifest.
5) Configuration for HTTP readiness probes also remains identical to liveness probes.
6) Readiness and liveness probes can be used in parallel for the same container.


Next topic: Self Healing Pods in kubsernetes (Restart Policy)
# Container Restart Policies
# 1) Always
# 2) OnFailure
# 3) Never

Restart Policies  (Refer section36_restartPolicies.yml)
1) Kubernetes have capability to Auto Restart the containers when they fails.
2) RestartPolicies customize the K8s Container Restart behaviour and you can choose when to Restart the Containers.
3) K8s have three restartPolicies - Always, OnFailure & Never

Always Restart Policy
1) Always is default restart policy in K8s.
2) With Always Policy, containers always restart even if container completed successfully.
3) This policy is recommended for containers that should always be in running state.

OnFailure Restart Policy
1) OnFailure is only works, if container Process exit with Error code.
2) It also works if container liveness probe determine the container unhealthy.
3) Use this policy on application that needs to be run successfully and then Stop.

Never Restart Policy
1) Never allow container to never restart even the container liveness probe failed.
2) Use this for application that Run only Once and never automatically restarted.

Next Topic: Multi Containers in pod (refer section36_multi-container.yml)

Multi Container Pods
1) Kubernetes Pods can have Single or Multiple Containers.
2) In Multi Container Pods, containers share the resources like network and storage, also can communicate on Local Host.
3) Note: Best Practice is to keep the containers in separate Pods, until we would like containers will share the resources.

Cross Container Comm.
1) Container sharing a Pod, can interact with Shared resources.
2) Network : Containers share the same Network and communicate on any Port, unless the port is exposed to cluster.
3) Storage : Containers Can use shared Volume to share the data in a Pod.

Next Topoic is Init containers (Refer section36_init_container.yml ans section36_initContainer-deoendency.yml)

Init Containers
1) Init Containers are specialized containers that run before app containers in a Pod.
2) Init Container only run once during the start-up process of Pod.
3) Init containers can contain utilities or setup scripts not present in an app image.
4) User Can define N Number of Init Container in Pod.

Init Containers: Use Case
1) SetUp the Application Init or SetUp Scripts.
2) Init containers offer a mechanism to block or delay app container startup until a set of preconditions are met.
3) Init containers can securely run utilities or custom code that would otherwise make an app container image less secure.
4) Populate Data at Shared Volume before Application StartUp.